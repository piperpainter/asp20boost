% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{report}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Report ASP20 Boost},
  pdfauthor={Johannes Strauß; Levin Wiebelt; Sebastian Aristizabal},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[left=4cm, right=3cm, top=2.5cm, bottom=2.5cm]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\title{Report ASP20 Boost}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{First Report}
\author{Johannes Strauß \and Levin Wiebelt \and Sebastian Aristizabal}
\date{04 Juni 2020}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{introduction}{%
\chapter{1. Introduction:}\label{introduction}}

\textbf{{[}S: please format all equations and terms - y, xi with a
subscripted i, zi (same), \ldots{]}}

The course ``Advanced Statistical Programming with R'' consists in
implementing a package to address location-scale regression. The sample
dataset consists of a response y, that's expectation is in linear
relationship to a set of predictors xi. Its variance, in contrast, is
dependent on a different set of linear predictors zi, however
transformed by the response function g(x) = exp(x). This ensures
positiveness of the variances. The goal approach is to estimate the
effects of both: xi on the expectation of y (location) - this is
captured by the estimates beta, and zi on the variance of y (scale) -
this is captured by the estimates gamma. Our student group
\texttt{asp20boost} solves this task applying the concept of boosting.

In \emph{part 2} of this report we explain the concept of boosting and
elaborate on how it suites to address the problem of location-scale
regression. In the following \emph{part 3} we describe our
implementation milestones, whereby \emph{part 4} especially elaborates
on componentwise boosting. In \emph{part 5} we present our thoughts on
upcoming challenges and critical aspects of the package development.

\hypertarget{concept-boosting}{%
\chapter{2. Concept: Boosting}\label{concept-boosting}}

\textbf{{[}S: please format all terms - xi, beta and gamma as greek
letters, v also as greek letter \ldots{]}} \textbf{{[}S: please add
reference{]}}

The first step in our progress was to understand the theoretical concept
of boosting, and which types of problems it is able to solve. To explain
the concept and follow our process of understanding we first explain
boosting for location parameters. Boosting scale parameters requires
another way of thinking about it and constituted a first milestone in
our understanding and implementation. In the following, the term
``booster'' refers to a boosting algorithm.

\hypertarget{location-booster}{%
\section{Location-Booster}\label{location-booster}}

The boosting concept relies on the idea of iterative estimation. To
estimate the location parameters beta via boosting, one starts with
initial estimates, which may be far from optimal. However, with
estimates and the response vector at hand, residuals can be calculated.
The boosting algortihm focuses on those calculated residuals. The effect
of the predictors xi on these residuals is estimated by least squares
and the resulting effect is added to the location-estimate beta,
adjusted by some learning rate \emph{v}. This yields a better fit of the
location-model, which results in smaller residuals. These new residuals
are estimated again in the next iteration, yielding smaller effect
sizes, and hence a convergence of the boosting algorithm towards the
OLS-estimate. A simple booster stops after a fixed number of iterations
is reached. \textbf{(compare Kneib et al, p217,218)}

\hypertarget{scale-booster}{%
\section{Scale-Booster}\label{scale-booster}}

A boosting algorithm for scale parameters \textbf{gamma} consists in the
same two repeating steps of first estimating a term, and second updating
\textbf{gamma} by adding the estimated effect - adjusted by a learning
rate. The term in the estimating step is, however, not the residual. For
boosting \textbf{gamma} this term equals the score function of the
model, that is the derivative of the loglikelihood of the normal
distribution.

\textbf{{[}Why is that? kurze Erklärung{]}}

\hypertarget{implementation}{%
\chapter{3. Implementation}\label{implementation}}

The implementation of the boosting algorithm is accomplished by a
function \emph{gradient\_boost}, which harmonizes with the R6-Class
\emph{LocationScaleRegressionBoost}. This class, in turn, is built upon
the \emph{LocationScaleRegression} class of the
\texttt{asp20model}-package. It follows a strict dependency of the
\texttt{asp20boost}- on the \texttt{asp20model}-package.

In the current version of the \texttt{asp20boost}-package, the boosting
algorithm is already implemented in order to allow componentwise
boosting, which will be explained in part 4. For good explanation and
for following our development process in this part we first describe the
implementation of ordinary boosting - which however does not appear in
our code anymore.

A simple booster for the location parameters \textbf{beta} works without
extending the \emph{LocationScaleRegression} class. The current
residuals may be extrated with the \emph{resid()}-method, then
estimated. The location parameter is updated. This causes the
\emph{LocationScaleRegression} class to calculate updated
state-dependent objects, such as the loglikelihood, gradients and the
residuals. This is what's needed to repeat the procedure of estimating
residuals and updating location parameters \textbf{Beta}.

The simple booster for the scale parameters \textbf{gamma}, as already
mentioned, consists in the same two repeating steps of first estimating
a term, and second updating the scale parameters gamma by adding the
estimated effect - adjusted by a learning rate \textbf{v}. The estimated
term here is the derivative of the loglikelihood of the normal
distribution. To calculate this, our code makes use of the
resid-function(), but this time passing the argument ``deviance'', which
results in residuals adjusted by the fitted scale estimates.

\textbf{{[}Erklärung weiter ausführen{]}}

Having implemented a boosting algorithm for location and scale, the
code-basis for our package was achieved.

\hypertarget{functionality-componentwise-boosting}{%
\chapter{4. Functionality: Componentwise
Boosting}\label{functionality-componentwise-boosting}}

A usefull functionality of boosting is componentwise boosting. The idea
is to not update a whole parameter vector, but only one entry of it. The
entry chosen for the update at this juncture is the one yielding the
best improvement in the sense of lowering the loss function. The loss
function in our case is the loglikelihood of the normally distributed
data. Hence in each iteration only one component of the location-, as
well as one component of the scale-parameters are updated.

The implementation in our package works via the extension of the
\textbf{LocationScaleRegression} class by two active fields
\emph{``bestFittingVariableBeta''} and
\emph{``bestFittingVariableGamma''}. These functions partition the
design matrix \emph{X} - respectively \emph{Z} - into its single columns
and then estimate the residuals - respectively the scores - seperately
for each component, and determine loss functions for a hypothetical
update with the respective component. Comparing with the old loss
function value, the highest loss-improvement may be determined and the
respective component is used to update the parameter-vector.

We are in the process of reconsidering the design of this
implementation. Other design possibilities are the following:

\begin{itemize}
\tightlist
\item
  create public fields for the heavily used score-function values
\item
  move the calculation of componentwise losses to an external function
\item
  harmonize boosting and componentwise boosting into one external
  function, determining the mode of operation by an argument
  `componentwise = TRUE'
\end{itemize}

Another conceptual questions that comes up is if the best
loss-improvement may be indicated by the already existing gradients, and
hence there is no need for extra calculation.

\hypertarget{prospects}{%
\chapter{5. Prospects}\label{prospects}}

\hypertarget{further-functionalities}{%
\section{Further Functionalities}\label{further-functionalities}}

The most important functionality we intend to implement in our package
is optimizing the stopping point of our booster. This optimization of
the number of iterations may be done via cross validation. Working out
the theoretical concept behind this idea is one of our next milestones.

One further, rather loose, idea is to find ways to optimize the learning
rate in our boosting algorithm.

\hypertarget{stability}{%
\section{Stability}\label{stability}}

We intend to implement further automated unit tests. This will enable us
to assess quickly the stability of our code given differing inputs.
Departing from this point we intend to reduce proneness to input errors.

\hypertarget{performance}{%
\section{Performance}\label{performance}}

\begin{itemize}
\tightlist
\item
  A major performance problem in our code is that small learning rates
  for the beta-booster cause processing time of the code to increase
  sharply. This remains to be solved. *A good choice of starting values
  for beta and gamma may enhance performance. A possible candidate is
  the mean of the response.
\end{itemize}

\hypertarget{further}{%
\section{Further}\label{further}}

\begin{itemize}
\item
  Allow user-input of the LocationScaleRegressionBoost-model in form of
  a dataframe, for example by allowing to pass an optional
  ``data''-argument as known from the lm-call. This may reduce proneness
  to input-errors.
\item
  Visualize the results of the boosted estimates
\item
  Document the extension of the R6-Class properly and inherit
  documentation of the LocationScaleRegression-Class applying roxygen2.
\end{itemize}

\hypertarget{application}{%
\section{Application}\label{application}}

{[}Johannes: Munich Rent Data? - Identify Outliers{]}

\end{document}
